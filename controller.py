import numpy as np
import torch

class AbstractController:
    """ Abstract class of controllers, to be inherited by the other classes
    """
    def __init__(self):
        self.counter = 0
    def reset(self):
        self.counter = 0
    def control(self, x):
        raise NotImplementedError

class RandomController(AbstractController):
    """ Generates random (normal) control actions
    """
    def __init__(self, N, q, mu=0, std=1):
        super().__init__()
        self.N = N
        self.q = q
        self.mu = mu
        self.std = std
    def control(self, x):
        unit_rand = torch.randn((x.size(0), self.N, self.q),
                dtype=torch.double, device=x.device)
        return unit_rand * self.std + self.mu

class ZeroController(AbstractController):
    """ Generates zeros control actions. (So we get the autonomous dynamics)
    """
    def __init__(self, N, q):
        super().__init__()
        self.N = N
        self.q = q
    def control(self, x):
        return torch.zeros((x.size(0), self.N,self.q),
                dtype=torch.double, device=x.device)

class GRNNController(AbstractController):
    """ A Controller wrapper for the parameters generated by our GRNN model
    """
    def __init__(self, model, batch_size):
        super().__init__()
        self.S, self.A, self.B = model.get_params()
        self.Z = self.A.new_zeros((batch_size, self.S.size(0), self.A.size(1)))
    def control(self, x):
        with torch.no_grad():
            self.Z = torch.tanh(self.S @ self.Z + x @ self.A)
            u = self.Z @ self.B
        return u
    def reset(self):
        super().reset()
        self.Z = Z.new_zeros(Z.size())  # Reset the hidden state
